{"version":3,"sources":["webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/calc.js","webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/cards.js","webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/forms.js","webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/modal.js","webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/slider.js","webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/tabs.js","webpack://lesson_37_creating_tabs_in_a_new_project/./js/modules/timer.js","webpack://lesson_37_creating_tabs_in_a_new_project/webpack/bootstrap","webpack://lesson_37_creating_tabs_in_a_new_project/./js/script.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA,SAAS;AACT,aAAa;AACb;AACA;AACA;;AAEA;;AAEA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA,yDAAyD;AACzD,6D;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;;AAEA,yCAAyC;AACzC;AACA,iBAAiB;;AAEjB,oDAAoD;AACpD;AACA,aAAa;;AAEb,SAAS;;;AAGT;;AAEA,2EAA2E;AAC3E;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA,sB;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4C;AACA;AACA;AACA;AACA;AACA,kB;AACA;AACA;AACA,uBAAuB,SAAS,OAAO,SAAS;AAChD,8CAA8C,WAAW;AACzD,4CAA4C,UAAU;AACtD;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA,qCAAqC;;AAErC,oBAAoB;AACpB;AACA,+CAA+C,IAAI,WAAW,WAAW;AACzE;;AAEA,gCAAgC;AAChC;;AAEA;AACA,kBAAkB;AAClB;AACA,uBAAuB,iCAAiC,IAAI;AAC5D,wFAAwF;AACxF,SAAS,EAAE;AACX,KAAK;;AAEL;AACA;AACA,qBAAqB;AACrB;AACA,mCAAmC,iCAAiC,IAAI;AACxE,+FAA+F;AAC/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9B,8BAA8B;AAC9B,mCAAmC,cAAc;AACjD,QAAQ;AACR;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA,iCAAiC;AACjC;AACA,YAAY;;AAEZ,0DAA0D;;AAE1D,kCAAkC;AAClC,yCAAyC,WAAW;AACpD,YAAY;AACZ;AACA;;AAEA;;AAEA,8BAA8B;AAC9B;AACA;;AAEA,4CAA4C;AAC5C;AACA,QAAQ;;AAER,4CAA4C;AAC5C;AACA,QAAQ;;AAER;;AAEA,wB;;;;;;;;;;AC9MA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,wC;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;AAEA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA,sB;;;;;;;;;;ACxCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA,0BAA0B;AAC1B;AACA,uBAAuB,IAAI;AAC3B,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA;;AAEA;;AAEA,uB;;;;;;UC1DA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;ACrBa;;AAEb;AACA;AACA,iBAAiB,mBAAO,CAAC,4CAAgB;AACzC,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C,iBAAiB,mBAAO,CAAC,4CAAgB;AACzC,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C,mBAAmB,mBAAO,CAAC,gDAAkB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;;;;AAIA,CAAC;;AAED;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["function calc(){\r\n    // Calc\r\n\r\n    const result = document.querySelector(\".calculating__result span\");\r\n    let sex, height, weight, age, ratio;\r\n\r\n    if(localStorage.getItem(\"sex\")){ // проверяем на то что пользователь до это устанавливал эти значения\r\n        sex = localStorage.getItem(\"sex\");\r\n    }\r\n    else{\r\n        sex = \"female\";\r\n        localStorage.setItem(\"sex\", \"famale\");\r\n    }\r\n\r\n    if(localStorage.getItem(\"ratio\")){ // проверяем на то что пользователь до это устанавливал эти значения\r\n        ratio = localStorage.getItem(\"ratio\");\r\n    }\r\n    else{\r\n        ratio = 1.375;\r\n        localStorage.setItem(\"ratio\", 1.375);\r\n    }\r\n\r\n    function calcTotal(){\r\n        if(!sex || !height || !weight || !age || !ratio){\r\n            result.textContent = \"_____\";\r\n            return;\r\n        }\r\n\r\n        if(sex === \"female\"){ // для женщин\r\n            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);\r\n        } // Math.round округлили\r\n        else{ // для мужчин\r\n            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);\r\n        }\r\n    }\r\n\r\n    calcTotal();\r\n\r\n    function initLocalSettings(selector, activeClass){ // установим класс активности на правильные элементы\r\n        const elements = document.querySelectorAll(selector);\r\n\r\n        elements.forEach(elem =>{\r\n            elem.classList.remove(activeClass);\r\n            if(elem.getAttribute(\"id\") === localStorage.getItem(\"sex\")){\r\n                elem.classList.add(activeClass);\r\n            }\r\n            if(elem.getAttribute(\"data-ratio\") === localStorage.getItem(\"ratio\")){\r\n                elem.classList.add(activeClass);\r\n            }\r\n        });\r\n    }\r\n    \r\n    initLocalSettings(\"#gender div\", \"calculating__choose-item_active\");\r\n    initLocalSettings(\".calculating__choose_big div\", \"calculating__choose-item_active\");\r\n\r\n    function getStaticInformation(selector, activeClass){//передаем родителя, и изначальный эл активности\r\n        const elements = document.querySelectorAll(selector); \r\n\r\n        elements.forEach(elem =>{\r\n            elem.addEventListener(\"click\", (e) =>{\r\n                if(e.target.getAttribute(\"data-ratio\")){ // если у элемента по которому кликнули есть атрибут \r\n                                                         // data-ratio то будем выполнять\r\n                    ratio = +e.target.getAttribute(\"data-ratio\");\r\n                    localStorage.setItem(\"ratio\", +e.target.getAttribute(\"data-ratio\"));\r\n                }\r\n                else{\r\n                    sex = e.target.getAttribute(\"id\");\r\n                    localStorage.setItem(\"sex\", e.target.getAttribute(\"id\")); // чтобы запоминался выбор пользов\r\n                }\r\n    \r\n                elements.forEach(elem =>{ // убираю класс активности во всех элементах родителя\r\n                    elem.classList.remove(activeClass);\r\n                });\r\n    \r\n                e.target.classList.add(activeClass); // добавляю класс активности элементу на который нажали\r\n                calcTotal();\r\n            });\r\n            \r\n        });\r\n\r\n        \r\n    }\r\n\r\n    getStaticInformation(\"#gender div\", \"calculating__choose-item_active\"); //#gender div\" - в первых аргументах\r\n    // в конце стоит див ибо ведь я обращаюсь к блокам которые находятся внутри этого #gender селектора\r\n    getStaticInformation(\".calculating__choose_big div\", \"calculating__choose-item_active\");\r\n\r\n    function getDynamicInformation(selector){\r\n        const input = document.querySelector(selector);\r\n\r\n        input.addEventListener(\"input\", ()=>{\r\n\r\n            if(input.value.match(/\\D/g)){ // если вводим букву, будет подствечивать \r\n                input.style.border =  \"1px solid red\";\r\n            }\r\n            else{\r\n                input.style.border = \"none\";\r\n            }\r\n\r\n\r\n            switch(input.getAttribute(\"id\")){\r\n                case \"height\": \r\n                    height = +input.value;\r\n                    break;\r\n                case \"weight\":\r\n                    weight = +input.value;\r\n                    break;\r\n                case \"age\":\r\n                    age = +input.value;\r\n                    break;\r\n\r\n            }\r\n\r\n            calcTotal();\r\n        });\r\n    }\r\n    \r\n    getDynamicInformation(\"#height\");\r\n    getDynamicInformation(\"#weight\");\r\n    getDynamicInformation(\"#age\");\r\n}\r\n\r\nmodule.exports = calc;","function cards(){\r\n    class MenuCard{\r\n        constructor(src, alt, title, desc, price, parentSelector, ...classes){\r\n            this.src = src;\r\n            this.alt = alt;\r\n            this.title = title;\r\n            this.classes = classes;\r\n            this.desc = desc;\r\n            this.price = price;\r\n            this.parent = document.querySelector(parentSelector); \r\n            this.transfer = 27;\r\n            this.ChangeToUAN();\r\n        }\r\n\r\n        ChangeToUAN(){\r\n            this.price = this.price * this.transfer;\r\n        }\r\n\r\n        render(){\r\n            const element = document.createElement(\"div\");\r\n            if(this.classes.length == 0){\r\n                this.element = \"menu__item\"; \r\n                element.classList.add(this.element);\r\n            }\r\n            this.classes.forEach(className => \r\n                element.classList.add(className)\r\n                ); \r\n            element.innerHTML = `\r\n            <div class=\"menu__item\">\r\n            <img src=${this.src} alt=${this.alt}>\r\n            <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n            <div class=\"menu__item-descr\">${this.desc}</div>\r\n            <div class=\"menu__item-divider\"></div>\r\n            <div class=\"menu__item-price\">\r\n                <div class=\"menu__item-cost\">Цена:</div>\r\n                <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div>\r\n            </div>\r\n         </div>\r\n            `;\r\n            this.parent.append(element);\r\n        }\r\n    }\r\n\r\n    const getResource = async (url) =>{ // у нас от сервера могут приходить ответы в различных форматах,\r\n        //  по этому всегда есть смысл выносить функционал в отдельную функцию, async означает что наша\r\n        // функция будет асинхронной \r\n        const res = await fetch(url); // мы помним что фетч у нас возвращает промис\r\n\r\n        if(!res.ok){ // так как промис выкидывает ошибку только в крайних случаях, там отсутствие инета,\r\n            //неправильно написан запрос, что-то в таком роде, то нам надо устроить дополнительную проверку\r\n            throw new Error(`could not fetch ${url} status: ${res.status}`);\r\n        }\r\n\r\n        return await res.json(); // делает из json обычный объект, вернет массив объект menucard\r\n    };\r\n\r\n    getResource(\"http://localhost:3000/menu\")\r\n    .then(data =>{ // после отрабатыва getResourse мы этот массив объектов перебираем форычем data.forEach и \r\n        // делаем деструктуризацию каждого объекта, после чего создаём новые элемент MenuCard\r\n        data.forEach(({img, altimg, title, descr, price})=>{ // выполнили деструктуризацию объекта \r\n            new MenuCard(img, altimg, title, descr, price, \".menu .container\").render(); // метод render\r\n        }); // описан выше\r\n    });\r\n\r\n    // axios.get(\"http://localhost:3000/menu\") // с помощью библиотеки axios сделали получение данных, плюшки в том,\r\n    // // что там уже встроенные разные проверки и тд\r\n    // .then(data =>{ // после отрабатыва getResourse мы этот массив объектов перебираем форычем data.forEach и \r\n    //         // делаем деструктуризацию каждого объекта, после чего создаём новые элемент MenuCard\r\n    //         data.data.forEach(({img, altimg, title, descr, price})=>{ // выполнили деструктуризацию объекта \r\n    //             new MenuCard(img, altimg, title, descr, price, \".menu .container\").render(); // метод render\r\n    //         }); // описан выше\r\n    //     });\r\n}\r\n\r\nmodule.exports = cards;","function forms(){\r\n    // Forms\r\n\r\n    const forms = document.querySelectorAll(\"form\");\r\n\r\n        const message = { // будет выводится пользователю при отправке формы\r\n            loading: \"img/form/spinner.svg\", // теперь будет выводится не слово загрузка а картинка\r\n            success: \"Спасибо, скоро мы с вами свяжемся\",\r\n            failure: \"Что-то пошло не так...\"\r\n        };\r\n        \r\n        forms.forEach(item =>{ // перебираем все формы и вызываем на каждой функцию постДата\r\n            bindPostData(item);\r\n        });\r\n\r\n        const postData = async (url, data) =>{ // у нас от сервера могут приходить ответы в различных форматах,\r\n            //  по этому всегда есть смысл выносить функционал в отдельную функцию, async означает что наша\r\n            // функция будет асинхронной \r\n            const res = await fetch(url, { // await - говорит что надо дождаться выполнения этого запроса\r\n                method: \"POST\", // метод которым будем обращаться к серверу\r\n                headers: { // заголовки, какой контент мы отправляем\r\n                'Content-type': 'applocation/json'\r\n            },\r\n                body: data // объект который будем посылать на сервер\r\n            }); // мы помним что фетч у нас возвращает промис\r\n            // после отправки данных теперь надо веернуть обычный объект\r\n\r\n            return await res.json(); // возвращаем этот промис, только будет ошибка ибо там у нас асинхронный код\r\n            // мы не знаем когда прийдет ответ от сервера который промис пытается получить, и в переменную res\r\n            // присвоится ничего, и а этого ничего мы вызываем метод json(), что приведет к ошибке, для этого\r\n            // надо сделать код синхронным и дождаться выполнения промиса, a тут await надо для того, ибо мы \r\n            // мы не знаем сколько времени нам надо чтобы перевести в json\r\n        };\r\n\r\n    function bindPostData(form){\r\n        form.addEventListener(\"submit\", (e) =>{ // submit - обработчик на отправление формы\r\n            e.preventDefault(); // отменили стандартное поведение формы, то есть перезагрузка страници\r\n\r\n            let statusMessage = document.createElement(\"img\");// создаем элемент в который закинем message\r\n            statusMessage.src = message.loading;\r\n            statusMessage.style.cssText = ` \r\n                display: block;\r\n                margin: 0, auto;\r\n            `; // сделали чтобы картинка блыка блочной и сделали её по средине\r\n            //form.append(statusMessage); // выводим сообщение о текущем результате обработки\r\n            form.insertAdjacentElement(\"afterend\", statusMessage);// с помощью этого метода мы аппендим наш\r\n            // спинер не в саму форму, а после неё\r\n\r\n            const formData = new FormData(form); // закидываем в formatData данные с формы\r\n\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries())); // formData.entries() преврати-\r\n            // ли форм дату в массив массивов по два элемента, после чего методом fromEntries этот массив\r\n            // массивов по два элемента превратили в объект, посли чего JSON.stringify сделали его json формата\r\n\r\n            postData(\"http://localhost:3000/requests\", json) // из postData вернется промис, который мы зенами отработаем\r\n            .then(data=>{\r\n                    console.log(data); // выводим в консоль чтобы пониматть что данные пошли на серв\r\n                    showThanksModal(message.success);\r\n                    statusMessage.remove(); // удаляем спинер\r\n            }).catch(()=>{\r\n                showThanksModal(message.failure);\r\n            }).finaly(()=>{ // так как в любом случаем нам надо очищать форму обратно, мы делаем это в finaly\r\n                form.reset(); // после отправки очистили форму\r\n            });\r\n            \r\n            \r\n\r\n            // Если внутри фетча профис попадает на ошибку которая связана с http протоколом типа 404, 502 \r\n            // или мы сделали ошибку в названии url b тд, это для него не считается ошибкой, он нормально \r\n            // выполнит при это resulve, самое главное для fetch это то что он вообще смог сделать этот запрос\r\n\r\n        });\r\n    }\r\n\r\n    function showThanksModal(message){\r\n        const prevModalDialog = document.querySelector(\".modal__dialog\");\r\n        prevModalDialog.classList.add(\"hide\"); // скрыли предыдущую форму отправки\r\n        openModal(); // функция отвечает за открытие модального окна(создали её чуть выше)\r\n\r\n        const thanksModal = document.createElement(\"div\");\r\n        thanksModal.classList.add(\"modal__dialog\");\r\n        thanksModal.innerHTML = `\r\n            <div class = \"modal__content\">\r\n                <div class = \"modal__close\" data-close>x</div>\r\n                <div class= \"modal__title\">${message}</div>\r\n            </div>\r\n        `; // в нашем модальном окне теперь выводится что спасибо и тд...\r\n\r\n        document.querySelector(\".modal\").append(thanksModal); // закидываем в наше модальное окно наш элемент\r\n        setTimeout(()=>{ // через 4 секунды чтобы убералось наше сообщение \r\n            thanksModal.remove(); // удаляем это сообщене (спасибо или не вышло)\r\n            prevModalDialog.classList.add(\"show\"); // возвращаем старое модальное окно заполнения\r\n            prevModalDialog.classList.remove(\"hide\"); // убираем класс который скрывает его\r\n            closeModal(); // закрываем модальное окно через 4сек\r\n        },4000);\r\n    }\r\n\r\n\r\n    \r\n    /*\r\n    // так работать на много легче, а XMLHttpRequest это уже устаревший формат\r\n    fetch('https://jsonplaceholder.typicode.com/posts',{ // а как делать другие виды запросов то есть POST\r\n    // либо Put запросы, для этого url отсаётся тот же, ставим запятую и помещаем туда сюда объект с настройками\r\n    // который мы будем задавать, он содержит много различных свойств, но самыми обязательными являются только\r\n    // method и body которое мы будем отправлять\r\n        method: \"POST\",\r\n        body: JSON.stringify({name: \"Alex\"}), // создали объект который превратится в JSON формат(stringify),\r\n        // и мы с вами отправим его при помощи fetch-а\r\n        headers: { // желательно добавлять еще заголовки которые будут оприделать какой контент мы отправляем\r\n            \"Content-type\": \"application/json\"\r\n        }  \r\n    })\r\n    .then((response) => { // мы получаем какойто response - ответ от сервера в формате json\r\n    return response.json(); // для того чтобы использовать этот json объект у себя на клиенте, нам надо\r\n    // трансформировать в обычный объект, для этого мы использовали в коде json.Parse, но в Fetch уже есть\r\n    // встроенная возможность быстро это сделать, для этого берем ответ от сервера и вызываем метод json(), и\r\n    // эта команда возвращает промис, для того чтобы построить дальше цепочку\r\n    })  \r\n    .then((data) => { // если там оно нормально все отработает мы получаем обычный объект \r\n    console.log(data); // и просто используем в консоли\r\n    }); \r\n    */\r\n\r\n    fetch(\"http://localhost:3000/menu\") // чтобы получить этот локал хост, нам надо прописать\r\n    .then(data=>{                       //npx json-server db.json и мы получили две ссылки на menu и нa request\r\n                                        // ну и дальше получаем данные с menu в виде массива\r\n        data.json(); // берем ответ от сервера, и превращаем в джаваскриптовый объект\r\n    })\r\n    .then(result => console.log(result));\r\n\r\n}\r\n\r\nmodule.exports = forms;","function modal(){\r\n    // Modal\r\n\r\n    const modalTrigger = document.querySelectorAll(\"[data-modal]\"); // для того чтобы получить атрибут надо еще\r\n    // квадратные скобочки\r\n    const modal = document.querySelector(\".modal\");\r\n\r\n    function openModal(){\r\n        modal.classList.add(\"show\");\r\n        modal.classList.remove(\"hide\");\r\n        document.body.style.overflow = \"hidden\"; // чтобы нельзя было скролить после открытия модального\r\n        clearInterval(modalTimerId);\r\n    }\r\n\r\n    modalTrigger.forEach(btn =>{\r\n        btn.addEventListener(\"click\", openModal);\r\n    });    \r\n\r\n    function closeModal(){\r\n        modal.classList.toggle(\"show\");\r\n        document.body.style.overflow = \"\"; // чтобы можно было скролить после закрытия\r\n    }\r\n    \r\n\r\n    modal.addEventListener(\"click\", (event) => {\r\n        if(event.target === modal || event.target.getAttribute(\"data-close\") == \"\"){\r\n           closeModal(); // а тут уже вызываем, ибо нам надо её выполнить после условия\r\n        }\r\n    });\r\n    \r\n    document.addEventListener(\"keydown\", (e)=>{ // при клике на ескейп будет закрываться\r\n        if(e.code === \"Escape\" && modal.classList.contains(\"show\")){ \r\n            closeModal();\r\n        }\r\n    });\r\n\r\n\r\n    const modalTimerId = setTimeout(openModal, 3000); // устанавливаем таймер на открытие модального окна\r\n\r\n    function ShowModalByScroll(){\r\n        if(window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight){\r\n            openModal();\r\n            window.removeEventListener(\"scroll\", ShowModalByScroll);\r\n        } // window.pageYOffset - прокрученая часть, второй параметр - часть которую я вижу, 3тий - больше\r\n        // либо ровна всему scrollHeight то мы долистали до конца\r\n    }\r\n\r\n    window.addEventListener(\"scroll\", ShowModalByScroll);\r\n}\r\n\r\nmodule.exports = modal;","function slider(){\r\n    // Slider\r\n    \r\n    const slides = document.querySelectorAll(\".offer__slide\"),\r\n          slider = document.querySelector(\".offer__slider\"),\r\n          prev = document.querySelector(\".offer__slider-prev\"),\r\n          next = document.querySelector(\".offer__slider-next\"),\r\n          total = document.querySelector(\"#total\"),\r\n          current = document.querySelector(\"#current\"),\r\n          slidesWrapper = document.querySelector(\".offer__slider-wrapper\"),\r\n          slidesField = document.querySelector(\".offer__slider-inner\"),\r\n          width = window.getComputedStyle(slidesWrapper).width;\r\n          \r\n    let slideIndex = 1;\r\n    let offset = 0; // переменная чттобы знать на сколько мы отступили вправо, или влево\r\n\r\n    if(slides.length < 10){ // меняется значение там где 04\r\n        total.textContent = `0${slides.length}`;\r\n        current.textContent = `0${slideIndex}`;\r\n    } else {\r\n        total.textContent = slides.length;\r\n        current.textContent = slideIndex;\r\n    }\r\n\r\n    slidesField.style.width = 100 * slides.length + \"%\"; // что блок занимае 100% ширины\r\n    slidesField.style.display = \"flex\"; // сделали флексом, чтобы слайды шли в бок\r\n    slidesField.style.transition = \"0.5s all\"; // плавный переход\r\n    \r\n    slidesWrapper.style.overflow = \"hidden\"; // скрыли все слайды которые уходят в бок, остался только основной\r\n\r\n    slides.forEach(slide =>{ // установили ширину всем слайдам\r\n        slide.style.width = width;\r\n    });\r\n\r\n    //точки\r\n    slider.style.position = \"relative\";\r\n\r\n    const indicators = document.createElement(\"ol\"),\r\n          dots = []; // в этот массив будем закидывать точки\r\n\r\n    indicators.classList.add(\"carousel-indicators\");\r\n\r\n    indicators.style.cssText = `\r\n        position: absolute;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        z-index: 15;\r\n        display: flex;\r\n        justify-content: center;\r\n        margin-right: 15%;\r\n        margin-left: 15%;\r\n        list-style: none;\r\n    `;\r\n\r\n    slider.append(indicators); // пока что мы добавили только список\r\n\r\n    for(let i = 0; i < slides.length; i++){ // создаём точки\r\n        const dot = document.createElement(\"li\");\r\n        dot.setAttribute(\"data-slide-to\", i+1); // каждой точке добавляем атрибут\r\n        dot.style.cssText = `\r\n            box-sizing: content-box;\r\n            flex: 0 1 auto;\r\n            width: 30px;\r\n            height: 6px;\r\n            margin-right: 3px;\r\n            margin-left: 3px;\r\n            cursor: pointer;\r\n            background-color: #fff;\r\n            background-clip: padding-box;\r\n            border-top: 10px solid transparent;\r\n            border-bottom: 10px solid transparent;\r\n            opacity: .5;\r\n            transition: opacity .6s ease;\r\n        `;\r\n\r\n        indicators.append(dot); // заапендили на страницу\r\n        dots.push(dot);\r\n\r\n    }\r\n\r\n    // /точки\r\n\r\n    function deleteNoDigits(str){ // функция по удалению букв из строки и замены строки на числовой тип\r\n        return +str.replace.replace(/\\D/g, \"\");\r\n    }\r\n\r\n    next.addEventListener(\"click\",  ()=>{ // когда я нажимаю кнопку вперед, оно будет сдвигать слайд\r\n        if(offset == deleteNoDigits(width) * (slides.length - 1)){\r\n           // сейчас у нас у width допустим 400px, нам надо это width умножить на количество слайдов, а как\r\n           //мы умножим значение где 400px нам надо убрать px для этого слайсом вырезаем и плюсиком делаем число\r\n            offset = 0; // это если у нас последнее число\r\n        } else {\r\n            offset+= deleteNoDigits(width); // к нашему офсету добавляется ширина еще одного слайда\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`; // и слайд смещается на оприделенную ширену \r\n        // если в ccs нам нужно сместить элемент влево то надо использовать отрицательные значения, вправо-полож\r\n\r\n        if(slideIndex==slides.length){\r\n            slideIndex = 1;\r\n        }else{\r\n            slideIndex++;\r\n        }\r\n\r\n        if(slides.length < 10){\r\n            current.textContent = `0${slideIndex}`;\r\n        }else{\r\n            current.textContent = slideIndex;\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = \"0.5\");// чтобы подсвечивался текущий элемент\r\n        dots[slideIndex - 1].style.opacity = 1;\r\n    });\r\n\r\n    prev.addEventListener(\"click\",  ()=>{ // когда я нажимаю кнопку вперед, оно будет сдвигать слайд\r\n        if(offset == 0){ // когда мы нажимаем прев и в нас первый слайд, мы смещаемся в конец\r\n            offset = deleteNoDigits(width) * (slides,length - 1); // replace(/\\D/g, \"\") - регулярное выраж\r\n        } else { // а если это был не первый слайд, то отнемаем ширину слайда\r\n            offset-= deleteNoDigits(width); // к нашему офсету добавляется ширина еще одного слайда\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`; // и слайд смещается на оприделенную ширену \r\n        // если в ccs нам нужно сместить элемент влево то надо использовать отрицательные значения, вправо-полож\r\n\r\n        if(slideIndex == 1){\r\n            slideIndex = slides.length;\r\n        }else{\r\n            slideIndex--;\r\n        }\r\n\r\n        if(slides.length < 10){\r\n            current.textContent = `0${slideIndex}`;\r\n        }else{\r\n            current.textContent = slideIndex;\r\n        }\r\n\r\n        dots.forEach(\r\n            dot => dot.style.opacity = \"0.5\"\r\n            ); // всем точкам прозрачность 0.5\r\n        dots[slideIndex - 1].style.opacity = 1; // чтобы подсвечивался текущий элемент\r\n    });\r\n\r\n    dots.forEach(dot => {\r\n        dot.addEventListener(\"click\", (e) =>{\r\n            const slideTo = e.target.getAttribute(\"data-slide-to\");\r\n\r\n            slideIndex = slideTo;\r\n            offset = deleteNoDigits(width) * (slideTo - 1);\r\n            slidesField.style.transform = `translateX(-${offset}px)`; // и слайд смещается на оприделенную ширену \r\n         //если в ccs нам нужно сместить элемент влево то надо использовать отрицательные значения, вправо-полож\r\n\r\n            dots.forEach(dot => dot.style.opacity = \"0.5\");// чтобы подсвечивался текущий элемент\r\n            dots[slideIndex - 1].style.opacity = 1;\r\n\r\n            if(slides.length < 10){ // текущий слайд\r\n                current.textContent = `0${slideIndex}`;\r\n            }else{\r\n                current.textContent = slideIndex;\r\n            }\r\n        });\r\n    });\r\n\r\n    // showSlides(slideIndex); // вызвали функцию чтобы изначально стоял первый слайд\r\n    // if(slides.length < 10){ // меняется значение там где 04\r\n    //     total.textContent = `0${slides.length}`;\r\n    // } else {\r\n    //     total.textContent = slides.length;\r\n    // }\r\n\r\n    // function showSlides(n){\r\n    //     if(n > slides.length){ // провераем гранчные значения\r\n    //         slideIndex = 1;\r\n    //     }\r\n    //     if(n < 1){ // проверяем граничные значения\r\n    //         slideIndex = slides.length;\r\n    //     }\r\n\r\n    //     slides.forEach(item=>{ // скрываем все слайды\r\n    //         item.style.display = \"none\";\r\n    //     });\r\n\r\n    //     slides[slideIndex - 1].style.display = \"block\"; // открыли 1вый слайд, то есть под индексом 0\r\n\r\n    //     if(slides.length < 10){ // изменяем чисто текущего слайда\r\n    //         current.textContent = `0${slideIndex}`;\r\n    //     } else {\r\n    //         current.textContent = slideIndex;\r\n    //     }\r\n\r\n    // }\r\n\r\n    // function plusSlides(n){ // функция по изменению индекса\r\n    //     showSlides(slideIndex += n);\r\n    // }\r\n\r\n    // prev.addEventListener(\"click\", () =>{ // при клике на стрелочку назад\r\n    //     plusSlides(-1);\r\n    // });\r\n\r\n    // next.addEventListener(\"click\", () =>{ // при клике на стрелочку вперед\r\n    //     plusSlides(+1);\r\n    // });\r\n\r\n}\r\n\r\nmodule.exports = slider;","function tabs(){\r\n    // Tabs\r\n\r\n    const tabs = document.querySelectorAll(\".tabheader__item\"),\r\n          tabsContent = document.querySelectorAll(\".tabcontent\"),\r\n          tabsParent = document.querySelector(\".tabheader__items\");\r\n     \r\n\r\n    function hideTabContent(){\r\n        tabsContent.forEach(item=>{\r\n            item.style.display = \"none\"; \r\n        });\r\n\r\n        tabs.forEach(tab=>{\r\n            tab.classList.remove(\"tabheader__item_active\");\r\n        });\r\n    }\r\n\r\n    function showTabContent(i = 0){ // по умолчанию если мы вызовем функцию там аргументом будет 0\r\n        tabsContent[i].style.display = \"block\";\r\n        tabs[i].classList.add(\"tabheader__item_active\");\r\n    }\r\n\r\n    hideTabContent();\r\n    showTabContent();\r\n\r\n    tabsParent.addEventListener(\"click\", (event) => {\r\n        const target = event.target;\r\n\r\n        if(target && target.classList.contains(\"tabheader__item\")){\r\n            tabs.forEach((item, i) =>{\r\n                if(target == item){\r\n                    hideTabContent();\r\n                    showTabContent(i);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = tabs;","function timer(){\r\n    // Timer\r\n\r\n    const deadLine = \"2020-11-30\";\r\n\r\n    function GetTimeRemaining(endtime){\r\n        const temp = Date.parse(endtime) - Date.parse(new Date()), // парс мы используем потому что мы не смогли бы\r\n        // отнять дату в от того формата, которым мы задали в deadLine, в t лежит количество милисекунд\r\n        days = Math.floor(temp / (1000 * 60 * 60 * 24)),// 1000 это одна секунда * 60 вышло минута * 60 = час * 24=сутки\r\n        hours = Math.floor((temp / (1000 * 60 * 60) % 24)), // выйдет что мы количество дней делим на 24 часа и получаем\r\n        // оствток %, это и будет наши часы\r\n        minutes = Math.floor((temp / 1000 / 60)%60 ), // при первом делении получаем кол. сек. потом / 60 = кол. мин.\r\n        seconds = Math.floor((temp / 1000) % 60);\r\n\r\n        return { // возвращаем объект\r\n            \"total\": temp,\r\n            \"days\": days,\r\n            \"hours\": hours,\r\n            \"minutes\": minutes,\r\n            \"seconds\": seconds\r\n        };\r\n    }  \r\n\r\n    function GetZero(num){ // исли у анс таймер будет с одной цифрой, будет добавлять спереди нолик\r\n        if(num >= 0 && num < 10){\r\n            return `0${num}`;\r\n        } else {\r\n            return num;\r\n        }\r\n    }\r\n\r\n    function setClock(selector, endtime){\r\n        const timer = document.querySelector(selector),\r\n              days = document.querySelector('#days'),\r\n              hours = document.querySelector('#hours'),\r\n              minutes = document.querySelector('#minutes'),\r\n              seconds = document.querySelector('#seconds'),\r\n              timeInterval = setInterval(updateClock, 1000); // установили интервал запуска функции\r\n              updateClock();//чтобы когда обновляем не ставилась старая дата а потом через секунду уже менялась, а сразу\r\n\r\n        function updateClock(){\r\n            const temp = GetTimeRemaining(endtime);\r\n\r\n            days.innerHTML = GetZero(temp.days);\r\n            hours.innerHTML = GetZero(temp.hours);\r\n            minutes.innerHTML = GetZero(temp.minutes);\r\n            seconds.innerHTML = GetZero(temp.seconds);\r\n\r\n            if(temp.total <= 0){\r\n                clearInterval(timeInterval); // то будем останавливать на таймер\r\n            }\r\n        }\r\n    }\r\n\r\n    setClock(\".timer\", deadLine);\r\n\r\n}\r\n\r\nmodule.exports = timer;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () =>{\n    // теперь все эти файлы пришло время перенести в гланый\n    const tabs = require(\"./modules/tabs\"),\n          modal = require(\"./modules/modal\"),\n          timer = require(\"./modules/timer\"),\n          cards = require(\"./modules/cards\"),\n          calc = require(\"./modules/calc\"),\n          forms = require(\"./modules/forms\"),\n          slider = require(\"./modules/slider\");\n\n    // теперь нам надо вызвать все эти функции\n    tabs();\n    modal();\n    timer();\n    cards();\n    calc();\n    forms();\n    slider(); \n\n    \n\n});\n\n// API - интерфейс програмного обеспечения, или приложения(Простыми словами это набор данных и возможностей\n// которые предоставляют нам какое-то решение)\n// Сегодня будем разбирать такую технологию как fach API - современная и крайнеудобная технология которая \n// позволяет общаться с сервером и она построена на промисах\n\n\n// npm пакеты - это кусочки кода, которые лежат на отдельных серверах и которые мы можем устанавливать себе в\n// проект, для того чтобы использовать\n// Прежде чем установить какие-то npm пакеты нам нужно системе сказать, что сейчас этот проэкт который открыт в\n// редакторе кода, будет содержать npm пакеты, то есть он превращается в npm проект\n// Чтобы инициализировать npm проект, открываем терминал(можно в VSСode), ИЛИ КОМАНДНУЮ СТРОКУ ЧЕРЕЗ КОТОРУЮ\n// ТЫ ОБРАЩАЕШЬСЯ К ГИТУ(это пизже)\n// пишем npm init, дальше устанавливаем имя, версию, описание и тд...\n// все, там создался файл package.json, он будет содержать информацию о нашем проэкте, а самое главное, \n// он будет содержать информацию о тех пакетах, которые мы в его поместим\n// Сейчас установим npm пакет json server, для установки пакета в терминале прописываем npm i (от слова install),\n// потом название пакета, то есть json-server, а дальше идут дополнительные параметры, мы можем его установить\n// локально(только в этом проэкте(для этого просто не надо ничего указывать)), а можем глобально(на всем компе, \n// для этого надо указать -g (от слова global) и если устанавливать вообще глобальные пакеты, то команду надо\n// всегда начинать из sudo, то есть sudo npm i json-server -g), теперь следующим этам нам надо установить флаг,\n// чтобы указать как этот пакет влияет на наш проект(то есть используется ли он при разработке, или при работе,\n// нашего проэекта) --save-dev это ключ который говорит что пакет используется при разработке, а если бы хотели\n// указать, что пакет используется при работе нашего проекта указали бы ключик --save \n// в итоге получилось (npm i json-server --save-dev)\n// там создалась папка node-modules, она много весит и её не нужно загружать на гитхаб, для этого должент быть\n// файл gitignore, где будут параметры которые указывают, что с проекта не надо загружать, а также могут воз-\n// никнуть трудности с удалением этой папки, для этого есть специальная команда\n// И если какой-то чел захочет скачать мой репозиторий с дополнительными пакетами которые должны бить\n// он просто потом пропишет в командную строку npm i и оно подгрузит все пакеты которые должны быть, так как \n// в packege.json уже есть инфа которые надо пакеты\n\n\n//___________\n// библиотека это какай-то маленький участок кода, либо целый большой ресурс который решает какую-то проблему,\n// Обычными словами библиотека - это готовое решение которые можно использовать\n// Только что подключили библиотку axios через CDN то есть по ссылке закинули в index.html, это не совсем\n// правльно, но пока можно и так, потом правильнее подключу, то есть через npm(или же npx) скачаю пакеты \n// Axios это очень удобная библиотека, которая позволяет работать с сервером, получать, постить и тд, \n// в неё уже завернуто много дополнительных возможностей которые нам бы приходилось каждый раз прописывать\n// в ручную, например мы прописывали проверку, где мы помним что промис не выкидывает ошибку в случае 404 или\n// чего-то подобного, а только жесткие показывет ошибки, по типу нет инета, и мы делали проверку на правльное\n// отрабатывание, в axios эта проверка уже прописана, то же самое с конвертацией в .json() \n"],"sourceRoot":""}